

# 数据通信项目 - 演示脚本使用指南

## 📋 概述

本指南介绍如何使用三个Level的演示脚本来展示完整的数据通信系统功能。

## 🎯 演示脚本列表

| 脚本名称 | 对应Level | 主要功能 | 生成文件 |
|---------|----------|---------|---------|
| `demo_level1.py` | Level 1 | 点对点通信基础 | 2个PNG图表 |
| `demo_level2.py` | Level 2 | 多主机网络通信 | 1个PNG图表 |
| `demo_level3.py` | Level 3 | 扩展功能演示 | 2-3个PNG图表 |

---

## 📊 Level 1: 点对点通信 (30分)

### 运行方式

```bash
cd mingled
python demo_level1.py
```

### 演示内容

#### ✅ 演示1：完整的比特流传输过程
- **展示内容**: 字符串编码 → 调制 → 信道传输 → 解调 → 解码的完整流程
- **实现方法**: 
  - BPSK调制 (1→+1V, 0→-1V)
  - 帧结构: [Preamble][Length][Payload]
  - 每比特20个采样点
  - 能量检测同步

#### ✅ 演示2：消息分片传输功能
- **展示内容**: 长消息分片、逐个传输、接收端重组
- **实现方法**: 
  - 按固定大小分割消息
  - 独立传输每个片段
  - 序列化重组

#### ✅ 演示3：不同噪声水平下的系统表现
- **展示内容**: 噪声对传输质量的影响
- **输出文件**: `level1_noise_impact.png`
- **测试范围**: 噪声 0.0 → 1.0
- **统计指标**: 误码率 (BER)

#### ✅ 演示4：香农公式对比
- **展示内容**: 实际吞吐量 vs 香农理论容量
- **输出文件**: `level1_shannon_comparison.png`
- **公式**: C = B × log₂(1 + SNR)
- **SNR范围**: -10dB → 20dB
- **关键发现**: BPSK在高SNR下无法逼近香农极限

### 评分要点

- ✅ 完整的比特流传输流程展示
- ✅ 消息分片功能实现
- ✅ 噪声影响可视化
- ✅ 与香农公式的对比分析

---

## 🌐 Level 2: 多主机通信 (30分)

### 运行方式

```bash
cd mingled
python demo_level2.py
```

### 演示内容

#### ✅ 演示1：寻址机制和数据包头设计

**如何区分不同的主机？**
- 使用MAC地址（Media Access Control Address）
- 每个主机分配唯一的8位地址 (0-255)
- 类似以太网的硬件地址概念

**数据包头设计：**

```
+----------------+----------------+----------------+
| 前导码 (8 bit) | 目标MAC (8 bit)| 源MAC (8 bit) |
+----------------+----------------+----------------+
| 长度 (8 bit)   | 载荷 (变长)     | CRC (32 bit)  |
+----------------+----------------+----------------+
```

**字段说明：**
- **前导码**: 同步序列 [1,0,1,0,1,0,1,0]
- **目标MAC**: 接收方地址
- **源MAC**: 发送方地址
- **长度**: 载荷字节数
- **载荷**: 实际数据
- **CRC**: 循环冗余校验，错误检测

#### ✅ 演示2：简单拓扑的多主机通信

**拓扑结构：**
```
Host A ←――→ Router ←――→ Host B
MAC:10       99         20
```

**通信场景：**
1. 直接通信: A → Router
2. 路由转发: A → Router → B

#### ✅ 演示3：复杂拓扑和多跳路由

**拓扑结构：**
```
Host A ←→ Router1 ←→ Router2 ←→ Host B
MAC:10      88         99         20
```

**路由逻辑：**
- 每个节点维护路由表
- 根据目标MAC地址查找下一跳
- 数据包经过多次转发到达目的地

#### ✅ 演示4：网络拓扑可视化

- **输出文件**: `level2_topology.png`
- 可视化展示网络结构
- 标注MAC地址和数据流向

### 路由与转发机制

**中心节点（Router）如何转发？**

1. **接收数据包**
   - 解调和解帧
   - 提取目标MAC地址

2. **查找路由表**
   ```python
   routing_table = {
       10: "HostA",   # 去往MAC 10要发给HostA
       20: "HostB",   # 去往MAC 20要发给HostB
   }
   ```

3. **转发决策**
   - 如果目标是自己：处理数据
   - 如果目标是其他节点：查表转发
   - 如果没有路由：丢弃并报错

4. **重新封装**
   - 保持原有的目标MAC和源MAC
   - 重新调制和传输

### 评分要点

- ✅ MAC地址寻址机制清晰
- ✅ 数据包头结构完整
- ✅ 路由表和转发逻辑正确
- ✅ 多跳路由功能正常
- ✅ 网络拓扑可视化

---

## 🚀 Level 3: 扩展功能 (最高40分)

### 运行方式

```bash
cd mingled
python demo_level3.py
```

然后根据菜单选择要演示的扩展功能（1-6）。

### 扩展功能列表

#### ✅ 扩展1：传输层可靠传输

**实现内容：**
- Stop-and-Wait ARQ协议
- ACK/NACK确认机制
- 超时重传
- 序列号管理（0和1交替）
- 去重机制

**通信流程：**
```
发送方                    接收方
  |                         |
  |---> DATA (Seq=0) ------>| 
  |                         | ✓
  |<---- ACK (Seq=0) <------|
  |                         |
  |---> DATA (Seq=1) ------>|
  |       (丢包)            |
  |... 超时 ...             |
  |---> DATA (Seq=1) ------>| 重传
  |                         | ✓
  |<---- ACK (Seq=1) <------|
```

**演示场景：**
- 使用LossyCable强制丢弃第一个包
- 观察超时检测和自动重传

#### ✅ 扩展2：信道编码

**实现内容：**
- Hamming(7,4) 纠错码
- 4数据位 → 7编码位
- 能纠正1位错误，检测2位错误

**编码原理：**
```
输入: [d1, d2, d3, d4]
输出: [p1, p2, d1, p3, d2, d3, d4]
      |校验位|  |数据位|
```

**性能测试：**
- 对比有无编码的BER
- 计算编码增益
- 分析传输速率影响

**输出文件：** `level3_channel_coding.png`

#### ✅ 扩展3：应用层协议

**实现内容：**
- HTTP-like协议
- GET请求
- 200 OK / 404 Not Found 响应
- 完整的请求-响应模式

**协议格式：**
```
请求: GET|/path/to/resource
响应: 200 OK|<content>
      404 Not Found|File missing
```

**演示场景：**
- 请求存在的资源 → 200 OK
- 请求不存在的资源 → 404 Not Found

#### ✅ 扩展4：性能优化

**实现内容：**
- ASK、FSK、BPSK 三种调制方式
- QPSK 高阶调制
- Hamming编码增强

**对比维度：**
1. **抗噪性能**: BER vs 噪声
2. **频谱效率**: bits/symbol
3. **实现复杂度**

**输出文件：** 通过 `performance_lab.py` 生成BER曲线

#### ✅ 扩展5：无线通信

**实现内容：**
- 无线信道模拟
- 瑞利衰落 (Rayleigh Fading)
- 多径传播效应

**实现方式：**
```python
class WirelessChannel(Cable):
    def transmit(signal):
        base_signal = super().transmit(signal)
        fading_factor = np.random.rayleigh(scale=0.9)
        fading_factor = np.clip(fading_factor, 0.2, 1.5)
        return base_signal * fading_factor
```

**对比测试：**
- 有线 vs 无线信道
- BER分布对比
- 波动性分析

**输出文件：** `level3_wireless.png`

### 评分要点

- ✅ 扩展功能实现完整
- ✅ 基于Level 2完整实现
- ✅ 现场演示功能正常
- ✅ 实现方法解释清晰
- ✅ 可视化图表专业

---

## 📸 录屏建议

### Level 1 录屏要点

1. **开始画面**: 显示脚本名称和Level 1标题
2. **演示1**: 运行基础传输，显示每一步的输出
3. **演示2**: 运行分片传输，显示片段传输过程
4. **演示3**: 显示噪声影响图表，解释趋势
5. **演示4**: 显示香农公式对比图，解释差距
6. **结束画面**: 总结Level 1完成情况

### Level 2 录屏要点

1. **开始画面**: 显示网络拓扑结构图
2. **演示1**: 展示数据包头结构，解释每个字段
3. **演示2**: 运行简单拓扑，观察路由转发
4. **演示3**: 运行复杂拓扑，展示多跳路由
5. **演示4**: 展示拓扑可视化图
6. **结束画面**: 总结路由机制

### Level 3 录屏要点

1. **开始画面**: 列出要演示的扩展功能
2. **每个扩展**: 
   - 解释实现方法
   - 运行演示
   - 展示可视化结果
   - 分析关键发现
3. **结束画面**: 总结所有扩展功能

---

## 🎨 生成的可视化文件

### Level 1

| 文件名 | 内容 | 用途 |
|--------|------|------|
| `level1_noise_impact.png` | 噪声对BER的影响 | 展示系统在不同噪声下的鲁棒性 |
| `level1_shannon_comparison.png` | 实际性能 vs 香农极限 | 展示BPSK的理论限制 |

### Level 2

| 文件名 | 内容 | 用途 |
|--------|------|------|
| `level2_topology.png` | 网络拓扑可视化 | 展示简单和复杂两种拓扑结构 |

### Level 3

| 文件名 | 内容 | 用途 |
|--------|------|------|
| `level3_channel_coding.png` | Hamming编码性能 | 展示纠错码的效果 |
| `level3_wireless.png` | 有线vs无线对比 | 展示瑞利衰落的影响 |
| `ber.png` | BER性能曲线 | 多种方案的BER对比 |

---

## 🔧 故障排除

### 问题1：导入错误
```
ImportError: No module named 'xxx'
```
**解决方案**: 确保在mingled文件夹中运行
```bash
cd /Users/gansz/Projects/EE315_project/mingled
python demo_level1.py
```

### 问题2：matplotlib不显示
```
图表窗口不弹出
```
**解决方案**: 
- 检查是否在GUI环境
- 图片仍会保存到文件
- 可以手动打开PNG文件查看

### 问题3：性能测试太慢
```
香农公式对比运行很久
```
**说明**: 这是正常的，需要测试25个SNR点，每个点传输5000 bits
**建议**: 耐心等待或减少测试点数量

---

## 📝 答辩准备清单

### Level 1
- [ ] 能流畅讲解比特流传输的每个步骤
- [ ] 能解释BPSK调制原理
- [ ] 能解释帧结构设计
- [ ] 能解读噪声影响图表
- [ ] 能解释为什么BPSK无法达到香农极限

### Level 2
- [ ] 能清楚说明MAC地址的作用
- [ ] 能详细解释数据包头的每个字段
- [ ] 能解释路由表的工作原理
- [ ] 能演示多跳路由的完整过程
- [ ] 能回答关于路由算法的问题

### Level 3
- [ ] 至少准备2-3个扩展功能
- [ ] 能详细解释每个功能的实现方法
- [ ] 能现场演示功能
- [ ] 能解读可视化图表
- [ ] 能回答关于协议设计的问题

---

## 🎯 快速开始

### 一键运行所有演示

```bash
cd mingled

# Level 1
python demo_level1.py

# Level 2  
python demo_level2.py

# Level 3
python demo_level3.py
```

### 运行测试验证

```bash
# 验证所有模块正常工作
python test_integration.py
```

---

## 📚 参考文档

- `README_VISUALIZATION.md` - 可视化模块使用指南
- `INTEGRATION_SUMMARY.md` - 技术实现细节
- `QUICKSTART.md` - 5分钟快速入门
- `FILES_OVERVIEW.md` - 文件说明

---

## 💡 最佳实践

1. **演示前准备**
   - 提前运行一遍所有脚本，确保正常工作
   - 准备好要讲解的关键点
   - 保存好生成的图表文件

2. **演示时注意**
   - 边运行边讲解，不要只是等待结果
   - 突出重点功能和创新点
   - 准备好回答可能的问题

3. **时间控制**
   - Level 1: 5-8分钟
   - Level 2: 5-8分钟
   - Level 3: 10-15分钟（根据演示的扩展数量）

---

**祝演示成功！** 🎉

