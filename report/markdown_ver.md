# Design and Implementation of a Full-Stack Network Simulation System: From Wireless Waveforms to Application Protocols

**Date:** November 2025  
**Course:** Data Communication and Networks

-----

## Abstract

This project involves the design and implementation of a comprehensive network communication system simulation, constructed entirely from scratch using Python. Unlike simple packet-level simulators, this system models the full protocol stack, ranging from raw signal processing at the Physical Layer to Application Layer interactions.

Key contributions of this implementation include:

1.  A versatile **Physical Layer** capable of dynamic switching between multiple modulation schemes (**ASK, FSK, BPSK**) over a realistic **Wireless Channel** characterized by Rayleigh Fading and Additive White Gaussian Noise (AWGN).
2.  A robust **Transport Layer** implementing a **Stop-and-Wait ARQ** protocol with precise sequence number tracking, timeout mechanisms, and retransmission logic to guarantee data delivery.
3.  The integration of advanced error control techniques, including **CRC-32** for detection and **Hamming (7,4)** codes for forward error correction.
4.  Exploration of advanced wireless concepts such as **MIMO (Multiple-Input Multiple-Output)** spatial multiplexing.

Experimental results, visualized through time-domain waveforms and sequence diagrams, demonstrate the system's capability to handle noise, recover from packet loss, and maintain data integrity across an unreliable medium.

-----

## I. Introduction

### A. Background and Objectives

Modern computer networks are built upon a layered architecture, typically represented by the OSI or TCP/IP models. Understanding the interactions between these layers—specifically how discrete bits are transformed into continuous analog signals and reliably transported across noisy, fading media—is fundamental to data communication.

The primary objective of this project is to simulate these cross-layer interactions without relying on high-level networking libraries. The specific goals achieved in this implementation are:

1.  **Physical Transmission**: Implement digital-to-analog conversion using multiple modulation techniques to analyze trade-offs in spectral efficiency and noise resilience.
2.  **Network Topology**: Simulate a multi-node environment where packets are addressed and routed based on MAC addresses.
3.  **Reliability**: Implement Automatic Repeat reQuest (ARQ) protocols to mask the unreliability of the physical channel from the upper layers.

### B. System Architecture

The system follows a modular object-oriented design in Python:

  * **`Cable` / `WirelessChannel`**: Simulates the physical medium, introducing attenuation, propagation delay, AWGN, and multipath fading.
  * **`Modem`**: Handles the conversion between digital bits and analog waveforms using configurable schemes (ASK, FSK, BPSK).
  * **`Host`**: Represents a network entity encapsulating the logic for the Link, Network, Transport, and Application layers.
  * **`Packet`**: Defines the protocol data unit (PDU) structure, including headers for addressing, sequencing, and error checking.

-----

## II. Physical Layer Implementation (Level 1 & Extensions)

The Physical Layer is the foundation of the simulation, responsible for transmitting raw bit streams over the medium. Unlike simple wire models, our system simulates a dynamic wireless environment.

### A. Multi-Scheme Modulation

To explore performance optimization, we implemented a flexible `Modem` class supporting three distinct modulation techniques. The transmitter maps binary data to analog waveforms $s(t)$:

1.  **Amplitude Shift Keying (ASK)**:

      * Information is carried in the amplitude.
      * Implementation: `1` maps to $+A$, `0` maps to $-A$ (Bipolar).
      * *Pros/Cons*: Simple to implement but highly susceptible to noise and fading.

2.  **Frequency Shift Keying (FSK)**:

      * Information is carried in the frequency.
      * Implementation: `1` maps to a high-frequency carrier ($f_1$), `0` maps to a low-frequency carrier ($f_2$).
      * *Pros/Cons*: More robust against amplitude variations but requires more bandwidth.

3.  **Binary Phase Shift Keying (BPSK)**:

      * Information is carried in the phase.
      * Implementation: `1` maps to $\sin(2\pi ft)$, `0` maps to $-\sin(2\pi ft)$ (180° phase shift).
      * *Pros/Cons*: Offers the best noise immunity (lowest BER for a given SNR) among the three.

**Visualization of Modulation Schemes:**
The figure below demonstrates the waveform differences generated by our simulation for the same bit sequence. Note the amplitude shifts in ASK, frequency density changes in FSK, and phase discontinuities in BPSK.

*Figure 1: Comparative visualization of ASK, FSK, and BPSK modulation schemes generated by the simulation.*

### B. Wireless Channel Model: Rayleigh Fading

Moving beyond simple attenuation, we extended the `Cable` class to create a `WirelessChannel`. The received signal $r(t)$ is modeled as:

$$r(t) = \alpha \cdot h \cdot s(t) + n(t)$$

Where:

  * $\alpha$ is the path loss attenuation.
  * $n(t)$ is Additive White Gaussian Noise (AWGN), $n \sim \mathcal{N}(0, \sigma^2)$.
  * $h$ is a random variable following a **Rayleigh distribution**, simulating multipath fading common in non-line-of-sight wireless environments. This causes the signal strength to fluctuate unpredictably, occasionally dropping below the detection threshold.

### C. Demodulation and Error Analysis

The receiver employs coherent detection logic (integration over symbol period) to recover bits. We validated the physical layer performance under different noise conditions.

**Scenario 1: Low Noise (Successful Recovery)**
In high SNR environments, the demodulator successfully reconstructs the digital bit stream.

*Figure 2: Successful Demodulation. The recovered bits (green) perfectly match the transmitted bits (blue).*

**Scenario 2: High Noise (Bit Errors)**
Under harsh wireless conditions (high noise or deep fading), the signal amplitude may fall below the decision threshold, or noise spikes may invert the bit polarity.

*Figure 3: Demodulation with Errors. High noise levels cause bit errors (marked with red 'X'), necessitating Upper Layer error control.*

-----

## III. Data Link & Network Layer (Level 2)

To support multi-host communication, we implemented framing and a static addressing mechanism.

### A. Framing and Encapsulation

The Data Link Layer encapsulates the payload into a structured Frame. The `Packet` class implements the following structure:

| Preamble | Dest MAC | Src MAC | Type | Seq Num | Payload | CRC |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 8 bits | 8 bits | 8 bits | 8 bits | 8 bits | Var | 8 bits |

  * **Preamble (10101010)**: Used by the Physical layer for synchronization.
  * **MAC Addresses**: Used for node identification.
  * **Type**: Distinguishes between `DATA` packets and `ACK` control packets.

### B. Routing Logic

Each `Host` node checks the **Destination MAC** of incoming frames:

1.  If `Dest MAC == Self MAC`: The packet is accepted and passed to the Transport Layer.
2.  If `Dest MAC != Self MAC`: In a multi-hop scenario, the node would lookup its routing table to forward the packet. In our shared-medium simulation, the packet is simply ignored (filtered out), simulating the behavior of a network interface card (NIC).

-----

## IV. Channel Coding (Level 3 Extension)

To mitigate the bit errors observed in the Physical Layer (Figure 3), we integrated Forward Error Correction (FEC).

### A. Hamming (7,4) Code

We implemented the Hamming (7,4) linear block code. This scheme encodes 4 data bits into 7 coded bits by calculating and appending 3 parity bits.

  * **Encoding**: The transmitter performs matrix multiplication $c = d \cdot G$, where $G$ is the generator matrix.
  * **Decoding**: The receiver calculates the syndrome $S = r \cdot H^T$, where $H$ is the parity check matrix. A non-zero syndrome identifies the exact position of a single-bit error, allowing the system to correct it automatically without retransmission.

This coding gain significantly improves the effective Bit Error Rate (BER) in medium-noise environments.

-----

## V. Transport Layer Reliability (Level 3 Extension)

While Channel Coding reduces bit errors, it cannot handle packet loss (e.g., due to deep fading where the entire signal is lost). To guarantee data integrity, we implemented a **Stop-and-Wait ARQ** (Automatic Repeat reQuest) protocol at the Transport Layer.

### A. Protocol Logic

The reliability mechanism implemented in the `Host` class involves:

1.  **Sequence Numbers (SEQ)**: Every packet is tagged with a sequence number (0, 1, 2...) to detect duplicates.
2.  **Pending Buffer**: Sent packets are stored in a `pending_acks` buffer along with a timestamp.
3.  **Timeout & Retransmission**: The host periodically runs `check_timeouts()`. If an ACK is not received within the timeout window (simulated as 3.0s), the packet is retrieved from the buffer and re-modulated.
4.  **Acknowledgements (ACK)**: Upon successful receipt and CRC validation, the receiver generates a control packet with `Type=ACK` and the matching SEQ number.

### B. Experimental Visualization

We conducted a real-time simulation where a packet was intentionally dropped by the wireless channel logic to test the system's resilience.

*Figure 4: Protocol Sequence Diagram generated from real-time simulation.*

**Analysis of Figure 4**:

  * **Left (Blue Zone)**: Normal communication using BPSK. The client sends data, and the server replies with an ACK.
  * **Right (Red Zone)**: A "Loss Zone" is simulated.
    1.  **Packet Loss**: The client sends `Seq=1`, but it is dropped (marked by the red cross and broken arrow).
    2.  **Timeout**: The client waits for the ACK but times out (marked by the orange diamond).
    3.  **Retransmission**: The client re-sends `Seq=1`. This time it succeeds, and the server acknowledges it.

-----

## VI. Application Layer & Advanced Wireless (Extensions)

### A. Application Layer Protocol

We designed a simplified text-based Request-Response protocol mimicking HTTP.

  * **Client**: Generates requests in the format `METHOD CONTENT` (e.g., `GET /index.html`).
  * **Server**: Parses the string. If the content exists in its internal storage, it returns `200 OK [Data]`; otherwise, it returns `404 Not Found`.
    This demonstrates the full vertical integration: a high-level user request is converted to bits, modulated to waveforms, transmitted wirelessly, error-checked, and finally processed by the server logic.

### B. MIMO (Multiple-Input Multiple-Output)

To maximize throughput, we extended the simulation model to support a $2 \times 2$ MIMO system using Spatial Multiplexing.

  * **Channel Model**: The channel is represented as a complex matrix $H$, where $h_{ij}$ represents the path gain from transmit antenna $j$ to receive antenna $i$.
    $$y = Hx + n$$
  * **Zero-Forcing Detection**: The receiver separates the mixed streams using the Zero-Forcing algorithm by calculating the pseudo-inverse of the channel matrix:
    $$\hat{x} = (H^H H)^{-1} H^H y$$
    This effectively inverts the channel effects, allowing two independent data streams to be transmitted simultaneously on the same frequency, doubling the spectral efficiency.

-----

## VII. Conclusion

This project successfully demonstrates the implementation of a full-stack network simulation system. By building the system from the ground up, we gained deep insights into the challenges of digital communication.

We moved beyond basic requirements by implementing a realistic **Wireless Physical Layer** with fading and dynamic multi-scheme modulation. The robustness of the system was rigorously verified through the **Transport Layer's** ability to handle packet loss, as visualized in our sequence diagrams. Advanced features like Channel Coding and MIMO further showcase the depth and scalability of the implemented architecture.